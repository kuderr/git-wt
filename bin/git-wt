#!/usr/bin/env bash
# git-wt — fast git worktree manager
# https://github.com/kuderr/git-wt
#
# Worktrees are stored globally at ~/.git-wt/<repo>/<name>/
# No files inside your repo. No .gitignore changes needed.

# shellcheck disable=SC2059  # intentional: ANSI color codes in printf format strings
set -euo pipefail

GIT_WT_VERSION="1.2.0"

# --- Config ---
GIT_WT_HOME="${GIT_WT_HOME:-${HOME}/.git-wt}"
WT_PREFIX="${GIT_WT_PREFIX:-wt}"
WT_BASE=""
WT_NO_BRANCH=false
WT_COPY_ENV=false
WT_QUIET=false

# --- Colors (respect NO_COLOR and non-tty) ---
if [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]; then
  RED=$'\033[0;31m'
  GREEN=$'\033[0;32m'
  YELLOW=$'\033[0;33m'
  BOLD=$'\033[1m'
  DIM=$'\033[2m'
  RESET=$'\033[0m'
else
  RED='' GREEN='' YELLOW='' BOLD='' DIM='' RESET=''
fi

# --- Name generation ---
ADJECTIVES=(
  agile bold brave bright calm clever cool crisp cubic daring
  eager fast fierce fleet fresh gentle grand happy keen kind
  lively lucid merry nimble noble plain prime proud quick quiet
  rapid sharp sleek smart snowy solid spicy stark steady sunny
  swift tense tidy vivid warm witty young zesty clear light
)
NOUNS=(
  arch beam bolt cape cove dawn dusk edge fern flux
  gale glen haze iris jade knot lace lynx mesa node
  opal peak pine quay reef sage tide vale wren zinc
  aura blaze crest drift ember frost grove haven inlet jewel
  kelp lotus marsh nexus orbit pulse ridge spark trail umbra
)

gen_name() {
  local adj=${ADJECTIVES[$RANDOM % ${#ADJECTIVES[@]}]}
  local noun=${NOUNS[$RANDOM % ${#NOUNS[@]}]}
  echo "${adj}-${noun}"
}

# --- Helpers ---
die() {
  printf "${RED}error:${RESET} %s\n" "$1" >&2
  exit 1
}

info() {
  $WT_QUIET || printf "${GREEN}%s${RESET}\n" "$1"
}

warn() {
  printf "${YELLOW}warning:${RESET} %s\n" "$1" >&2
}

get_repo_root() {
  local toplevel
  toplevel=$(git rev-parse --show-toplevel 2>/dev/null) && echo "$toplevel" && return

  # might be inside a worktree — resolve via git common dir
  local common
  common=$(git rev-parse --git-common-dir 2>/dev/null)
  if [[ -n "$common" && "$common" != ".git" ]]; then
    (cd "$common" && cd .. && pwd)
    return
  fi

  die "not inside a git repository"
}

get_repo_name() {
  basename "$(get_repo_root)"
}

resolve_wt_dir() {
  echo "${GIT_WT_HOME}/$(get_repo_name)"
}

current_branch() {
  git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD"
}

# Resolve a worktree name or path to its absolute path.
# Checks: managed name → absolute path → external basename match.
resolve_wt_path() {
  local arg="$1"
  local wt_root
  wt_root=$(resolve_wt_dir)

  # 1. Managed worktree by name
  if [[ -d "${wt_root}/${arg}" ]]; then
    echo "${wt_root}/${arg}"
    return 0
  fi

  # 2. Absolute path — verify it's a known worktree
  if [[ "$arg" == /* ]]; then
    if git worktree list --porcelain | grep -q "^worktree ${arg}$"; then
      echo "$arg"
      return 0
    fi
    return 1
  fi

  # 3. Match basename among external worktrees
  local repo_root matches=()
  repo_root=$(get_repo_root)
  local wt_path=""

  while IFS= read -r line; do
    case "$line" in
      "worktree "*)  wt_path="${line#worktree }" ;;
      "bare")        wt_path="" ;;
      "")
        if [[ -n "$wt_path" && "$wt_path" != "$repo_root" && "$wt_path" != "${wt_root}/"* ]]; then
          if [[ "$(basename "$wt_path")" == "$arg" ]]; then
            matches+=("$wt_path")
          fi
        fi
        wt_path=""
        ;;
    esac
  done < <(git worktree list --porcelain && echo "")

  if [[ ${#matches[@]} -eq 1 ]]; then
    echo "${matches[0]}"
    return 0
  elif [[ ${#matches[@]} -gt 1 ]]; then
    printf "error: ambiguous name '%s' matches multiple external worktrees:\n" "$arg" >&2
    for m in "${matches[@]}"; do
      printf "  %s\n" "$m" >&2
    done
    printf "Use the full path instead.\n" >&2
    return 1
  fi

  return 1
}

# List worktree names for the current repo (used by completions)
_wt_names() {
  local wt_root
  wt_root=$(resolve_wt_dir)
  if [[ -d "$wt_root" ]]; then
    # shellcheck disable=SC2012
    ls "$wt_root" 2>/dev/null
  fi

  # Include external worktree basenames
  local repo_root wt_path=""
  repo_root=$(get_repo_root 2>/dev/null) || return
  while IFS= read -r line; do
    case "$line" in
      "worktree "*)  wt_path="${line#worktree }" ;;
      "bare")        wt_path="" ;;
      "")
        if [[ -n "$wt_path" && "$wt_path" != "$repo_root" && "$wt_path" != "${wt_root}/"* ]]; then
          basename "$wt_path"
        fi
        wt_path=""
        ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null && echo "")
}

# --- Commands ---
cmd_new() {
  local name=""
  local positional=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--base)    WT_BASE="$2"; shift 2 ;;
      -p|--prefix)  WT_PREFIX="$2"; shift 2 ;;
      --no-branch)  WT_NO_BRANCH=true; shift ;;
      --copy-env)   WT_COPY_ENV=true; shift ;;
      -*)           die "unknown option: $1" ;;
      *)            positional+=("$1"); shift ;;
    esac
  done

  name="${positional[0]:-$(gen_name)}"
  local wt_root
  wt_root=$(resolve_wt_dir)
  local wt_path="${wt_root}/${name}"

  if [[ -d "$wt_path" ]]; then
    die "worktree '${name}' already exists at ${wt_path}"
  fi

  local base="${WT_BASE:-$(current_branch)}"
  local branch="${WT_PREFIX}/${name}"

  mkdir -p "$wt_root"

  if $WT_NO_BRANCH; then
    info "Creating worktree '${name}' (detached HEAD from ${base})..."
    git worktree add --detach "$wt_path" "$base"
  else
    info "Creating worktree '${name}' on branch '${branch}' from '${base}'..."
    git worktree add -b "$branch" "$wt_path" "$base"
  fi

  # Copy env files if requested
  if $WT_COPY_ENV; then
    local repo_root
    repo_root=$(get_repo_root)
    local copied=0
    for envfile in "${repo_root}"/.env*; do
      if [[ -f "$envfile" ]]; then
        cp "$envfile" "$wt_path/"
        $WT_QUIET || printf "  Copied %s\n" "$(basename "$envfile")"
        copied=$((copied + 1))
      fi
    done
    if [[ $copied -eq 0 ]]; then
      warn "no .env* files found to copy"
    fi
  fi

  echo ""
  printf "${BOLD}Worktree ready:${RESET}\n"
  printf "  Path:   %s\n" "${wt_path}"
  if ! $WT_NO_BRANCH; then
    printf "  Branch: %s\n" "${branch}"
  fi
  echo ""
  printf "  ${DIM}cd %s${RESET}\n" "${wt_path}"
}

cmd_list() {
  local wt_root
  wt_root=$(resolve_wt_dir)
  local repo_name
  repo_name=$(get_repo_name)
  local repo_root
  repo_root=$(get_repo_root)

  local output="" count=0
  local wt_path="" wt_branch="" wt_head="" is_bare=false

  while IFS= read -r line; do
    case "$line" in
      "worktree "*)  wt_path="${line#worktree }" ;;
      "branch "*)    wt_branch="${line#branch refs/heads/}" ;;
      "HEAD "*)      wt_head="${line#HEAD }" ;;
      "detached")    wt_branch="(detached ${wt_head:0:7})" ;;
      "bare")        is_bare=true ;;
      "")
        if ! $is_bare && [[ -n "$wt_path" && "$wt_path" != "$repo_root" ]]; then
          local wt_name status tag=""
          wt_name=$(basename "$wt_path")

          if [[ ! -d "$wt_path" ]]; then
            status="${RED}missing${RESET}"
          elif (cd "$wt_path" 2>/dev/null && [[ -n "$(git status --porcelain 2>/dev/null)" ]]); then
            status="${YELLOW}modified${RESET}"
          else
            status="${GREEN}clean${RESET}"
          fi

          if [[ "$wt_path" != "${wt_root}/"* ]]; then
            tag="  ${DIM}[external]${RESET}"
          fi

          output+="$(printf "  %-20s %-30s %b%b\n" "$wt_name" "${wt_branch:-unknown}" "$status" "$tag")"$'\n'
          output+="$(printf "  ${DIM}  → %s${RESET}\n" "$wt_path")"$'\n'
          count=$((count + 1))
        fi
        wt_path="" wt_branch="" wt_head="" is_bare=false
        ;;
    esac
  done < <(git worktree list --porcelain && echo "")

  if [[ $count -eq 0 ]]; then
    echo "No worktrees for '${repo_name}'"
    return
  fi

  printf "${BOLD}Worktrees for %s${RESET} ${DIM}(%s)${RESET}\n\n" "$repo_name" "$wt_root"
  printf "  %-20s %-30s %s\n" "NAME" "BRANCH" "STATUS"
  printf "  ${DIM}%-20s %-30s %s${RESET}\n" "----" "------" "------"
  printf "%s" "$output"
}

cmd_list_all() {
  if [[ ! -d "$GIT_WT_HOME" ]] || [[ -z "$(ls -A "$GIT_WT_HOME" 2>/dev/null)" ]]; then
    echo "No worktrees found in ${GIT_WT_HOME}"
    return
  fi

  printf "${BOLD}All worktrees${RESET} ${DIM}(%s)${RESET}\n\n" "$GIT_WT_HOME"

  for repo_dir in "${GIT_WT_HOME}"/*/; do
    [[ -d "$repo_dir" ]] || continue
    local repo
    repo=$(basename "$repo_dir")
    local count=0

    # Collect managed worktrees
    for wt_dir in "${repo_dir}"/*/; do
      [[ -d "$wt_dir" ]] || continue
      local name
      name=$(basename "$wt_dir")
      local branch
      branch=$(cd "$wt_dir" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "???")
      if [[ $count -eq 0 ]]; then
        printf "  ${BOLD}%-18s${RESET} %-20s ${DIM}%s${RESET}\n" "$repo" "$name" "$branch"
      else
        printf "  %-18s %-20s ${DIM}%s${RESET}\n" "" "$name" "$branch"
      fi
      printf "  %-18s ${DIM}→ %s${RESET}\n" "" "${wt_dir%/}"
      count=$((count + 1))
    done

    if [[ $count -eq 0 ]]; then
      printf "  ${BOLD}%-18s${RESET} ${DIM}(empty)${RESET}\n" "$repo"
    fi
  done
}

cmd_rm() {
  local arg="${1:?Usage: git wt rm <name|path>}"
  local wt_root
  wt_root=$(resolve_wt_dir)
  local wt_path=""

  # Resolve: managed name, or absolute path under wt_root
  if [[ -d "${wt_root}/${arg}" ]]; then
    wt_path="${wt_root}/${arg}"
  elif [[ "$arg" == /* && "$arg" == "${wt_root}/"* && -d "$arg" ]]; then
    wt_path="$arg"
  fi

  if [[ -z "$wt_path" ]]; then
    # Check if it's an external worktree — hint the user to adopt first
    if resolve_wt_path "$arg" >/dev/null 2>&1; then
      die "worktree '${arg}' is external — run 'git wt adopt' first"
    fi
    die "worktree '${arg}' not found"
  fi

  local name
  name=$(basename "$wt_path")

  # Get branch name before removing
  local branch
  branch=$(cd "$wt_path" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

  info "Removing worktree '${name}'..."
  git worktree remove "$wt_path" --force

  # Delete the branch (safe — this is a managed worktree)
  if [[ -n "$branch" && "$branch" != "HEAD" ]]; then
    if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
      info "Deleting branch '${branch}'..."
      git branch -D "$branch" 2>/dev/null || true
    fi
  fi

  # Clean up empty repo directory
  if [[ -d "$wt_root" ]] && [[ -z "$(ls -A "$wt_root" 2>/dev/null)" ]]; then
    rmdir "$wt_root"
  fi

  info "Done."
}

cmd_path() {
  local name="${1:?Usage: git wt path <name|path>}"
  local wt_path

  if ! wt_path=$(resolve_wt_path "$name"); then
    die "worktree '${name}' not found"
  fi

  echo "$wt_path"
}

cmd_adopt() {
  local positional=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -*)  die "unknown option: $1" ;;
      *)   positional+=("$1"); shift ;;
    esac
  done

  local path="${positional[0]:?Usage: git wt adopt <name|path> [name]}"
  local name="${positional[1]:-}"

  # Try resolving as external worktree name first, then as path
  if [[ "$path" != /* ]] && [[ ! -d "$path" ]]; then
    local resolved
    if resolved=$(resolve_wt_path "$path" 2>/dev/null); then
      path="$resolved"
    else
      die "worktree '${path}' not found"
    fi
  else
    # Resolve relative path to absolute
    if [[ "$path" != /* ]]; then
      path=$(cd "$path" 2>/dev/null && pwd) || die "path does not exist: ${positional[0]}"
    fi
    # Validate it's a real worktree
    if ! git worktree list --porcelain | grep -q "^worktree ${path}$"; then
      die "'${path}' is not a git worktree"
    fi
  fi

  # Can't adopt the main worktree (use cmd_origin logic for reliable detection)
  local repo_root
  repo_root=$(cmd_origin)
  if [[ "$path" == "$repo_root" ]]; then
    die "cannot adopt the main worktree"
  fi

  local wt_root
  wt_root=$(resolve_wt_dir)

  # Already managed?
  if [[ "$path" == "${wt_root}/"* ]]; then
    die "worktree is already managed by git-wt at ${path}"
  fi

  # Derive name
  if [[ -z "$name" ]]; then
    name=$(basename "$path")
  fi

  local target="${wt_root}/${name}"

  if [[ -d "$target" ]]; then
    die "worktree '${name}' already exists at ${target}"
  fi

  mkdir -p "$wt_root"

  info "Adopting worktree '${name}'..."
  git worktree move "$path" "$target"

  # Get branch info
  local branch
  branch=$(cd "$target" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

  echo ""
  printf "${BOLD}Worktree adopted:${RESET}\n"
  printf "  Path:   %s\n" "${target}"
  printf "  Branch: %s\n" "${branch}"
  echo ""
  printf "  ${DIM}cd %s${RESET}\n" "${target}"
}

cmd_origin() {
  local common_dir
  common_dir=$(git rev-parse --git-common-dir 2>/dev/null) || die "not inside a git repository"

  if [[ "$common_dir" == ".git" ]]; then
    git rev-parse --show-toplevel
  else
    (cd "$common_dir" && cd .. && pwd)
  fi
}

cmd_open() {
  local name="${1:?Usage: git wt open <name>}"
  local wt_path
  wt_path=$(cmd_path "$name")

  if command -v cursor &>/dev/null; then
    cursor "$wt_path"
  elif command -v code &>/dev/null; then
    code "$wt_path"
  elif [[ -n "${EDITOR:-}" ]]; then
    $EDITOR "$wt_path"
  else
    warn "no editor found (tried: cursor, code, \$EDITOR)"
    echo "  cd ${wt_path}"
  fi
}

cmd_clean() {
  local wt_root
  wt_root=$(resolve_wt_dir)
  local repo_name
  repo_name=$(get_repo_name)

  if [[ ! -d "$wt_root" ]] || [[ -z "$(ls -A "$wt_root" 2>/dev/null)" ]]; then
    echo "No worktrees to clean for '${repo_name}'."
    return
  fi

  local count=0
  for dir in "${wt_root}"/*/; do
    [[ -d "$dir" ]] || continue
    local name
    name=$(basename "$dir")
    cmd_rm "$name"
    count=$((count + 1))
  done

  if [[ $count -eq 0 ]]; then
    echo "No worktrees to clean."
  else
    info "Cleaned ${count} worktree(s)."
  fi

  git worktree prune
}

cmd_help() {
  cat <<EOF
${BOLD}git-wt${RESET} v${GIT_WT_VERSION} — fast git worktree manager

Worktrees are stored in ${DIM}${GIT_WT_HOME}/<repo>/<name>/${RESET}

${BOLD}Usage:${RESET}
  git wt new [name]            Create a new worktree (auto-names if omitted)
  git wt list                  List worktrees for current repo
  git wt list-all              List managed worktrees across all repos
  git wt adopt <name|path> [name]  Adopt an external worktree into git-wt
  git wt rm <name|path>        Remove a managed worktree and its branch
  git wt path <name|path>      Print worktree path
  git wt origin                Print main repo path (origin of worktree)
  git wt open <name|path>      Open worktree in editor
  git wt clean                 Remove all managed worktrees for current repo

${BOLD}Options for new:${RESET}
  -b, --base <branch>      Base branch to fork from (default: current)
  -p, --prefix <prefix>    Branch prefix (default: wt/)
  --no-branch              Use detached HEAD
  --copy-env               Copy .env* files into new worktree

${BOLD}Environment:${RESET}
  GIT_WT_HOME              Worktrees root (default: ~/.git-wt)
  GIT_WT_PREFIX            Default branch prefix (default: wt)

${BOLD}Examples:${RESET}
  git wt new                       ${DIM}# ~/.git-wt/myrepo/swift-jade/${RESET}
  git wt new my-feature            ${DIM}# ~/.git-wt/myrepo/my-feature/${RESET}
  git wt new -b main hotfix        ${DIM}# fork from main${RESET}
  git wt new --copy-env experiment ${DIM}# also copies .env files${RESET}
  cd \$(git wt path my-feature)     ${DIM}# jump into worktree${RESET}
  git wt open my-feature           ${DIM}# open in Cursor/VS Code${RESET}
  git wt adopt ../my-hotfix        ${DIM}# adopt external worktree${RESET}
  git wt rm my-feature             ${DIM}# clean up${RESET}

${DIM}https://github.com/kuderr/git-wt${RESET}
EOF
}

# --- Main ---
# Global flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    -q|--quiet) WT_QUIET=true; shift ;;
    *)          break ;;
  esac
done

command="${1:-help}"
shift || true

case "$command" in
  new)              cmd_new "$@" ;;
  list|ls)          cmd_list "$@" ;;
  list-all)         cmd_list_all "$@" ;;
  rm|remove)        cmd_rm "$@" ;;
  path|cd)          cmd_path "$@" ;;
  adopt)            cmd_adopt "$@" ;;
  origin)           cmd_origin "$@" ;;
  open)             cmd_open "$@" ;;
  clean)            cmd_clean "$@" ;;
  help|--help|-h)   cmd_help ;;
  version|--version|-v) echo "git-wt ${GIT_WT_VERSION}" ;;
  _names)           _wt_names ;;  # internal: used by completions
  *)
    die "unknown command: ${command}\nRun 'git wt help' for usage."
    ;;
esac
